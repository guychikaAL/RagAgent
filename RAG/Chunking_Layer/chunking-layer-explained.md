# Chunking Layer - Complete Guide

## ğŸ“š **What is the Chunking Layer?**

The Chunking Layer transforms a **single claim document** into a **3-level hierarchical structure** of nodes (Sections â†’ Parent Chunks â†’ Child Chunks). This hierarchy enables both **high-precision** retrieval (atomic facts) and **high-recall** retrieval (broad context).

---

## ğŸ¯ **Core Responsibility**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              CHUNKING LAYER                             â”‚
â”‚        (Text â†’ Hierarchical Nodes)                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                         â”‚
â”‚  INPUT:  One Claim Document                             â”‚
â”‚          (from Claim Segmentation Layer)                â”‚
â”‚                                                         â”‚
â”‚  OUTPUT: List[BaseNode] with 3-level hierarchy:        â”‚
â”‚          â€¢ Sections (logical divisions)                 â”‚
â”‚          â€¢ Parent Chunks (250-600 tokens)               â”‚
â”‚          â€¢ Child Chunks (80-150 tokens)                 â”‚
â”‚                                                         â”‚
â”‚  DOES:                                                  â”‚
â”‚  âœ… Section detection                                   â”‚
â”‚  âœ… Hierarchical chunking                               â”‚
â”‚  âœ… Node creation with relationships                    â”‚
â”‚  âœ… Metadata enrichment                                 â”‚
â”‚                                                         â”‚
â”‚  DOES NOT:                                              â”‚
â”‚  âŒ Create embeddings (Index Layer's job)               â”‚
â”‚  âŒ Build vector stores (Index Layer's job)             â”‚
â”‚  âŒ Perform retrieval (Index Layer's job)               â”‚
â”‚  âŒ Mix claims (each claim processed independently)     â”‚
â”‚                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ—ï¸ **3-Level Hierarchical Structure**

```
Claim Document
     â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  LEVEL 1: SECTIONS                           â”‚
â”‚  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”   â”‚
â”‚  â€¢ Logical divisions within the claim        â”‚
â”‚  â€¢ Detected by: SECTION keywords, ALL CAPS   â”‚
â”‚  â€¢ Node type: IndexNode (organizational)     â”‚
â”‚  â€¢ Example: "CLAIMANT INFORMATION",          â”‚
â”‚             "VEHICLE DETAILS"                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â†“ (contains)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  LEVEL 2: PARENT CHUNKS                      â”‚
â”‚  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”   â”‚
â”‚  â€¢ Semantic units (250-600 tokens)           â”‚
â”‚  â€¢ Approx: 1-2 paragraphs                    â”‚
â”‚  â€¢ Node type: TextNode (contains full text)  â”‚
â”‚  â€¢ Used by: Summary Agent (high recall)      â”‚
â”‚  â€¢ Example: Full paragraph about accident    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â†“ (contains)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  LEVEL 3: CHILD CHUNKS                       â”‚
â”‚  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”   â”‚
â”‚  â€¢ Atomic fact units (80-150 tokens)         â”‚
â”‚  â€¢ Approx: 1-3 sentences                     â”‚
â”‚  â€¢ Node type: TextNode (contains full text)  â”‚
â”‚  â€¢ Used by: Needle Agent (high precision)    â”‚
â”‚  â€¢ Example: "Claimant: Jon Mor, Phone:       â”‚
â”‚             555-1234"                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ”„ **Complete Chunking Pipeline**

### **Overview:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           CHUNKING PIPELINE (6 STAGES)                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                          â”‚
â”‚  Input: Claim Document (from Claim Segmentation)        â”‚
â”‚     â†“                                                     â”‚
â”‚  Stage 1: Section Detection                             â”‚
â”‚     â†“                                                     â”‚
â”‚  Stage 2: Parent Chunking (per section)                 â”‚
â”‚     â†“                                                     â”‚
â”‚  Stage 3: Child Chunking (per parent)                   â”‚
â”‚     â†“                                                     â”‚
â”‚  Stage 4: Relationship Linking                          â”‚
â”‚     â†“                                                     â”‚
â”‚  Stage 5: Metadata Enrichment                           â”‚
â”‚     â†“                                                     â”‚
â”‚  Stage 6: Cleaning & Validation                         â”‚
â”‚     â†“                                                     â”‚
â”‚  Output: List[BaseNode] (hierarchical nodes)            â”‚
â”‚                                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“Š **Stage 1: Section Detection**

### **Purpose:**
Detect logical sections within the claim document using text patterns.

### **Flow:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚             STAGE 1: SECTION DETECTION                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                          â”‚
â”‚  Input: Claim Document Text                             â”‚
â”‚     â†“                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚ Analyze Text Patterns                          â”‚     â”‚
â”‚  â”‚ â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”   â”‚     â”‚
â”‚  â”‚ Pattern 1: SECTION Keywords                    â”‚     â”‚
â”‚  â”‚   â€¢ "SECTION 1", "SECTION A", etc.             â”‚     â”‚
â”‚  â”‚   â€¢ Regex: SECTION\s+[A-Z0-9]+                 â”‚     â”‚
â”‚  â”‚                                                â”‚     â”‚
â”‚  â”‚ Pattern 2: ALL CAPS Headings                   â”‚     â”‚
â”‚  â”‚   â€¢ Short lines (< 80 chars)                   â”‚     â”‚
â”‚  â”‚   â€¢ All uppercase                              â”‚     â”‚
â”‚  â”‚   â€¢ Multiple words (2-12 words)                â”‚     â”‚
â”‚  â”‚   â€¢ Not ending with punctuation                â”‚     â”‚
â”‚  â”‚                                                â”‚     â”‚
â”‚  â”‚ Example matches:                               â”‚     â”‚
â”‚  â”‚ âœ“ "CLAIMANT INFORMATION"                       â”‚     â”‚
â”‚  â”‚ âœ“ "VEHICLE DETAILS"                            â”‚     â”‚
â”‚  â”‚ âœ“ "SECTION 1 - ACCIDENT DETAILS"               â”‚     â”‚
â”‚  â”‚ âŒ "This is a sentence."                        â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚     â†“                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚ Create Section Objects                         â”‚     â”‚
â”‚  â”‚ â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”   â”‚     â”‚
â”‚  â”‚ For each detected section marker:             â”‚     â”‚
â”‚  â”‚                                                â”‚     â”‚
â”‚  â”‚ Section {                                      â”‚     â”‚
â”‚  â”‚   title: "CLAIMANT INFORMATION",               â”‚     â”‚
â”‚  â”‚   text: "...section content...",               â”‚     â”‚
â”‚  â”‚   start_char: 0,                               â”‚     â”‚
â”‚  â”‚   end_char: 500,                               â”‚     â”‚
â”‚  â”‚   position_index: 0                            â”‚     â”‚
â”‚  â”‚ }                                              â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚     â†“                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚ Fallback: No Sections Detected                â”‚     â”‚
â”‚  â”‚ â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”   â”‚     â”‚
â”‚  â”‚ If no sections found:                          â”‚     â”‚
â”‚  â”‚ â€¢ Create ONE default section                   â”‚     â”‚
â”‚  â”‚ â€¢ Title: "Document"                            â”‚     â”‚
â”‚  â”‚ â€¢ Contains entire document                     â”‚     â”‚
â”‚  â”‚                                                â”‚     â”‚
â”‚  â”‚ WHY: Ensures consistent structure              â”‚     â”‚
â”‚  â”‚      (always at least 1 section)               â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚     â†“                                                     â”‚
â”‚  Output: List[Section]                                   â”‚
â”‚          (1+ section objects)                            â”‚
â”‚                                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### **Section Detection Example:**

```
Input Text:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
AUTO CLAIM FORM #001

CLAIMANT INFORMATION
Name: Jon Mor
Phone: 555-1234
Address: 123 Main St

VEHICLE DETAILS
Make: Toyota
Model: Camry
Year: 2020

SECTION 1 - ACCIDENT DETAILS
Date: 2024-06-06
Time: 14:30
Location: Main St & Oak Ave
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Detected Sections:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Section 0: "CLAIMANT INFORMATION"
  Text: "Name: Jon Mor\nPhone: 555-1234..."
  Chars: 0-150

Section 1: "VEHICLE DETAILS"
  Text: "Make: Toyota\nModel: Camry..."
  Chars: 150-280

Section 2: "SECTION 1 - ACCIDENT DETAILS"
  Text: "Date: 2024-06-06\nTime: 14:30..."
  Chars: 280-450
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```

---

## ğŸ“¦ **Stage 2: Parent Chunking**

### **Purpose:**
Split each section into parent chunks (250-600 tokens / 1-2 paragraphs).

### **Flow:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚             STAGE 2: PARENT CHUNKING                     â”‚
â”‚         (For each section independently)                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                          â”‚
â”‚  Input: Section Text                                    â”‚
â”‚     â†“                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚ Split by Paragraphs                            â”‚     â”‚
â”‚  â”‚ â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”   â”‚     â”‚
â”‚  â”‚ â€¢ Split on: \n\n (double newline)              â”‚     â”‚
â”‚  â”‚ â€¢ WHY: Paragraphs are natural semantic units   â”‚     â”‚
â”‚  â”‚                                                â”‚     â”‚
â”‚  â”‚ Paragraphs: [Para1, Para2, Para3, ...]        â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚     â†“                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚ Build Chunks (250-600 tokens)                  â”‚     â”‚
â”‚  â”‚ â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”   â”‚     â”‚
â”‚  â”‚ current_chunk = []                             â”‚     â”‚
â”‚  â”‚ current_size = 0                               â”‚     â”‚
â”‚  â”‚                                                â”‚     â”‚
â”‚  â”‚ For each paragraph:                            â”‚     â”‚
â”‚  â”‚   tokens = estimate_tokens(paragraph)          â”‚     â”‚
â”‚  â”‚                                                â”‚     â”‚
â”‚  â”‚   if tokens > 600:  # Para too large          â”‚     â”‚
â”‚  â”‚     Split by sentences                         â”‚     â”‚
â”‚  â”‚   elif current_size + tokens > 600:            â”‚     â”‚
â”‚  â”‚     Flush current_chunk                        â”‚     â”‚
â”‚  â”‚     Start new chunk with this para             â”‚     â”‚
â”‚  â”‚   else:                                        â”‚     â”‚
â”‚  â”‚     Add para to current_chunk                  â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚     â†“                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚ Create Parent TextNodes                        â”‚     â”‚
â”‚  â”‚ â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”   â”‚     â”‚
â”‚  â”‚ For each chunk:                                â”‚     â”‚
â”‚  â”‚                                                â”‚     â”‚
â”‚  â”‚ TextNode {                                     â”‚     â”‚
â”‚  â”‚   text: "CLAIM NUMBER: 001\n" +                â”‚     â”‚
â”‚  â”‚         "AUTO CLAIM FORM #001\n" +             â”‚     â”‚
â”‚  â”‚         "[chunk text]",                        â”‚     â”‚
â”‚  â”‚                                                â”‚     â”‚
â”‚  â”‚   metadata: {                                  â”‚     â”‚
â”‚  â”‚     parent_id: "parent_section0_0",            â”‚     â”‚
â”‚  â”‚     section_id: "section_0",                   â”‚     â”‚
â”‚  â”‚     chunk_level: "parent",                     â”‚     â”‚
â”‚  â”‚     position_index: 0,                         â”‚     â”‚
â”‚  â”‚     token_length: 450,                         â”‚     â”‚
â”‚  â”‚     claim_id: "claim_001",                     â”‚     â”‚
â”‚  â”‚     claim_number: "001",                       â”‚     â”‚
â”‚  â”‚     contains_dates: true,                      â”‚     â”‚
â”‚  â”‚     semantic_topic: "Claimant Jon Mor..."      â”‚     â”‚
â”‚  â”‚   },                                           â”‚     â”‚
â”‚  â”‚                                                â”‚     â”‚
â”‚  â”‚   relationships: {                             â”‚     â”‚
â”‚  â”‚     PARENT: section_node                       â”‚     â”‚
â”‚  â”‚   }                                            â”‚     â”‚
â”‚  â”‚ }                                              â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚     â†“                                                     â”‚
â”‚  Output: List[TextNode] (parent chunks)                 â”‚
â”‚                                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### **Parent Chunking Configuration:**

```python
parent_chunk_size = 400 tokens       # Target size
parent_chunk_overlap = 50 tokens     # Overlap for context

# Token Estimation:
# ~4 chars per token (English average)
# 400 tokens â‰ˆ 1600 chars â‰ˆ 1-2 paragraphs
```

---

### **Parent Chunking Example:**

```
Section: "CLAIMANT INFORMATION"
Text: ~2000 chars / 500 tokens

Split into Parent Chunks:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Parent Chunk 0 (450 tokens):
  "CLAIM NUMBER: 001
   AUTO CLAIM FORM #001
   
   Claimant Information:
   Name: Jon Mor
   Phone: 555-1234
   Address: 123 Main St, Apt 4B
   Email: jon.mor@email.com
   Date of Birth: 1985-03-15
   
   Emergency Contact:
   Name: Jane Mor
   Relationship: Spouse
   Phone: 555-5678"

Parent Chunk 1 (380 tokens):
  "CLAIM NUMBER: 001
   AUTO CLAIM FORM #001
   
   Employment Information:
   Employer: Tech Corp
   Occupation: Software Engineer
   Work Phone: 555-9012
   
   Insurance Information:
   Policy Number: INS-123456
   Coverage Type: Full Coverage
   Premium: $150/month"
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```

---

### **Why Prepend Claim Context?**

```
Original chunk text:
  "Name: Jon Mor
   Phone: 555-1234"

Enhanced chunk text (what gets embedded):
  "CLAIM NUMBER: 001
   AUTO CLAIM FORM #001
   Name: Jon Mor
   Phone: 555-1234"
   â†‘ Prepended context

WHY THIS MATTERS:
âœ… Queries like "claim 001" will match correctly
âœ… Claim number is prominent in embeddings
âœ… Better semantic matching for claim-specific queries
âœ… Prevents confusion when indexing multiple claims
```

---

## ğŸ”¬ **Stage 3: Child Chunking**

### **Purpose:**
Split each parent chunk into child chunks (80-150 tokens / 1-3 sentences).

### **Flow:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚             STAGE 3: CHILD CHUNKING                      â”‚
â”‚         (For each parent chunk independently)            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                          â”‚
â”‚  Input: Parent TextNode                                 â”‚
â”‚     â†“                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚ Split by Sentences                             â”‚     â”‚
â”‚  â”‚ â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”   â”‚     â”‚
â”‚  â”‚ â€¢ Split on: . ! ?                              â”‚     â”‚
â”‚  â”‚ â€¢ WHY: Sentences are atomic fact boundaries    â”‚     â”‚
â”‚  â”‚                                                â”‚     â”‚
â”‚  â”‚ Sentences: [Sent1, Sent2, Sent3, ...]         â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚     â†“                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚ Build Chunks (80-150 tokens) with Overlap      â”‚     â”‚
â”‚  â”‚ â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”   â”‚     â”‚
â”‚  â”‚ current_chunk = []                             â”‚     â”‚
â”‚  â”‚ current_size = 0                               â”‚     â”‚
â”‚  â”‚                                                â”‚     â”‚
â”‚  â”‚ For each sentence:                             â”‚     â”‚
â”‚  â”‚   tokens = estimate_tokens(sentence)           â”‚     â”‚
â”‚  â”‚                                                â”‚     â”‚
â”‚  â”‚   if current_size + tokens > 150:              â”‚     â”‚
â”‚  â”‚     Flush current_chunk                        â”‚     â”‚
â”‚  â”‚                                                â”‚     â”‚
â”‚  â”‚     # Apply overlap (keep last sentence)       â”‚     â”‚
â”‚  â”‚     if overlap_enabled:                        â”‚     â”‚
â”‚  â”‚       current_chunk = [last_sent, sentence]    â”‚     â”‚
â”‚  â”‚     else:                                      â”‚     â”‚
â”‚  â”‚       current_chunk = [sentence]               â”‚     â”‚
â”‚  â”‚   else:                                        â”‚     â”‚
â”‚  â”‚     Add sentence to current_chunk              â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚     â†“                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚ Create Child TextNodes                         â”‚     â”‚
â”‚  â”‚ â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”   â”‚     â”‚
â”‚  â”‚ For each chunk:                                â”‚     â”‚
â”‚  â”‚                                                â”‚     â”‚
â”‚  â”‚ TextNode {                                     â”‚     â”‚
â”‚  â”‚   text: "[1-3 sentences of atomic facts]",    â”‚     â”‚
â”‚  â”‚                                                â”‚     â”‚
â”‚  â”‚   metadata: {                                  â”‚     â”‚
â”‚  â”‚     child_id: "child_parent0_0",               â”‚     â”‚
â”‚  â”‚     parent_id: "parent_section0_0",            â”‚     â”‚
â”‚  â”‚     section_id: "section_0",                   â”‚     â”‚
â”‚  â”‚     chunk_level: "child",                      â”‚     â”‚
â”‚  â”‚     position_index: 0,                         â”‚     â”‚
â”‚  â”‚     token_length: 120,                         â”‚     â”‚
â”‚  â”‚     claim_id: "claim_001",                     â”‚     â”‚
â”‚  â”‚     claim_number: "001",                       â”‚     â”‚
â”‚  â”‚     is_atomic_fact: true                       â”‚     â”‚
â”‚  â”‚   },                                           â”‚     â”‚
â”‚  â”‚                                                â”‚     â”‚
â”‚  â”‚   relationships: {                             â”‚     â”‚
â”‚  â”‚     PARENT: parent_node,                       â”‚     â”‚
â”‚  â”‚     SOURCE: section_node                       â”‚     â”‚
â”‚  â”‚   }                                            â”‚     â”‚
â”‚  â”‚ }                                              â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚     â†“                                                     â”‚
â”‚  Output: List[TextNode] (child chunks)                  â”‚
â”‚                                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### **Child Chunking Configuration:**

```python
child_chunk_size = 120 tokens        # Target size
child_chunk_overlap = 20 tokens      # Overlap for context

# 120 tokens â‰ˆ 480 chars â‰ˆ 1-3 sentences
```

---

### **Child Chunking Example:**

```
Parent Chunk (450 tokens):
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
"CLAIM NUMBER: 001
AUTO CLAIM FORM #001

Claimant Information:
Name: Jon Mor
Phone: 555-1234
Address: 123 Main St, Apt 4B
Email: jon.mor@email.com
Date of Birth: 1985-03-15

Emergency Contact:
Name: Jane Mor
Relationship: Spouse
Phone: 555-5678"
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Split into Child Chunks:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Child Chunk 0 (110 tokens):
  "CLAIM NUMBER: 001 AUTO CLAIM FORM #001 
   Claimant Information: Name: Jon Mor 
   Phone: 555-1234 Address: 123 Main St, Apt 4B"
   â†‘ Atomic fact: Claimant contact info

Child Chunk 1 (95 tokens):
  "Address: 123 Main St, Apt 4B 
   Email: jon.mor@email.com 
   Date of Birth: 1985-03-15"
   â†‘ Overlap + new info
   â†‘ Atomic fact: Claimant personal details

Child Chunk 2 (85 tokens):
  "Emergency Contact: Name: Jane Mor 
   Relationship: Spouse Phone: 555-5678"
   â†‘ Atomic fact: Emergency contact
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```

---

### **Why Overlap Matters:**

```
Without Overlap:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Chunk 1: "...Address: 123 Main St."
Chunk 2: "Email: jon@email.com..."
         â†‘ Missing context!

Problem: Query "Jon Mor's address and email" 
         might only retrieve Chunk 1

With Overlap:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Chunk 1: "...Address: 123 Main St."
Chunk 2: "Address: 123 Main St. Email: jon@email.com..."
         â†‘ Has context from previous chunk!

Benefit: Both chunks contain address context,
         improving retrieval quality
```

---

## ğŸ”— **Stage 4: Relationship Linking**

### **Purpose:**
Establish parent-child relationships between nodes for hierarchical navigation.

### **Relationship Types:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              NODE RELATIONSHIPS                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                          â”‚
â”‚  Section (IndexNode)                                    â”‚
â”‚     â†“ CHILD relationship                                 â”‚
â”‚  Parent Chunk (TextNode)                                â”‚
â”‚     â†‘ PARENT relationship                                â”‚
â”‚     â†“ CHILD relationship                                 â”‚
â”‚  Child Chunk (TextNode)                                 â”‚
â”‚     â†‘ PARENT relationship                                â”‚
â”‚     â†‘ SOURCE relationship                                â”‚
â”‚                                                          â”‚
â”‚  Enables:                                               â”‚
â”‚  â€¢ Upward navigation (child â†’ parent â†’ section)         â”‚
â”‚  â€¢ Downward navigation (section â†’ parents â†’ children)   â”‚
â”‚  â€¢ AutoMergingRetriever (merges children to parent)     â”‚
â”‚  â€¢ RecursiveRetriever (navigates hierarchy)             â”‚
â”‚                                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### **Relationship Linking Flow:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         STAGE 4: RELATIONSHIP LINKING                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                          â”‚
â”‚  For each Section:                                      â”‚
â”‚     â†“                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚ Link Section â†’ Parent Chunks                   â”‚     â”‚
â”‚  â”‚ â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”   â”‚     â”‚
â”‚  â”‚ section_node.relationships[CHILD] = [          â”‚     â”‚
â”‚  â”‚   parent_1, parent_2, parent_3, ...            â”‚     â”‚
â”‚  â”‚ ]                                              â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚     â†“                                                     â”‚
â”‚  For each Parent Chunk:                                 â”‚
â”‚     â†“                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚ Link Parent â†’ Section (upward)                 â”‚     â”‚
â”‚  â”‚ â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”   â”‚     â”‚
â”‚  â”‚ parent_node.relationships[PARENT] =            â”‚     â”‚
â”‚  â”‚   section_node                                 â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚     â†“                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚ Link Parent â†’ Child Chunks                     â”‚     â”‚
â”‚  â”‚ â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”   â”‚     â”‚
â”‚  â”‚ parent_node.relationships[CHILD] = [           â”‚     â”‚
â”‚  â”‚   child_1, child_2, child_3, ...               â”‚     â”‚
â”‚  â”‚ ]                                              â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚     â†“                                                     â”‚
â”‚  For each Child Chunk:                                  â”‚
â”‚     â†“                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚ Link Child â†’ Parent (upward)                   â”‚     â”‚
â”‚  â”‚ â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”   â”‚     â”‚
â”‚  â”‚ child_node.relationships[PARENT] =             â”‚     â”‚
â”‚  â”‚   parent_node                                  â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚     â†“                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚ Link Child â†’ Section (source reference)        â”‚     â”‚
â”‚  â”‚ â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”   â”‚     â”‚
â”‚  â”‚ child_node.relationships[SOURCE] =             â”‚     â”‚
â”‚  â”‚   section_node                                 â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚                                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### **Relationship Graph:**

```
                Section Node
              (IndexNode)
          "CLAIMANT INFORMATION"
                   â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚          â”‚          â”‚
   Parent 0    Parent 1    Parent 2
  (TextNode)  (TextNode)  (TextNode)
   450 tokens  380 tokens  420 tokens
        â”‚          â”‚          â”‚
    â”Œâ”€â”€â”€â”¼â”€â”€â”€â”  â”Œâ”€â”€â”€â”¼â”€â”€â”€â”  â”Œâ”€â”€â”€â”¼â”€â”€â”€â”
    â”‚   â”‚   â”‚  â”‚   â”‚   â”‚  â”‚   â”‚   â”‚
   C0  C1  C2  C3  C4  C5  C6  C7  C8
  (TextNode for each child chunk)
   110t 95t 85t 120t 100t 90t 115t 105t 100t

Relationships:
  Section â†’ Parent: CHILD
  Parent â†’ Section: PARENT
  Parent â†’ Child: CHILD
  Child â†’ Parent: PARENT
  Child â†’ Section: SOURCE
```

---

## ğŸ·ï¸ **Stage 5: Metadata Enrichment**

### **Purpose:**
Add rich metadata to each node for filtering, debugging, and analysis.

### **Metadata Types:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              NODE METADATA                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                          â”‚
â”‚  STRUCTURAL METADATA:                                    â”‚
â”‚  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”   â”‚
â”‚  â€¢ node_id: "child_parent0_0"                            â”‚
â”‚  â€¢ chunk_level: "child" | "parent" | "section"           â”‚
â”‚  â€¢ position_index: 0, 1, 2, ...                          â”‚
â”‚  â€¢ parent_id: "parent_section0_0"                        â”‚
â”‚  â€¢ section_id: "section_0"                               â”‚
â”‚                                                          â”‚
â”‚  CLAIM METADATA (CRITICAL):                              â”‚
â”‚  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”   â”‚
â”‚  â€¢ claim_id: "claim_001"                                 â”‚
â”‚  â€¢ claim_number: "001"                                   â”‚
â”‚  â€¢ claimant_name: "Jon Mor" (dynamic!)                   â”‚
â”‚                                                          â”‚
â”‚  SEMANTIC METADATA:                                      â”‚
â”‚  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”   â”‚
â”‚  â€¢ token_length: 120                                     â”‚
â”‚  â€¢ semantic_topic: "Claimant Jon Mor contact..."         â”‚
â”‚  â€¢ contains_dates: true | false                          â”‚
â”‚  â€¢ contains_times: true | false                          â”‚
â”‚  â€¢ contains_numbers: true | false                        â”‚
â”‚                                                          â”‚
â”‚  DOCUMENT METADATA:                                      â”‚
â”‚  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”   â”‚
â”‚  â€¢ document_id: "doc_123"                                â”‚
â”‚  â€¢ document_type: "insurance_claim_form"                 â”‚
â”‚  â€¢ source_type: "pdf"                                    â”‚
â”‚                                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### **Why Metadata Matters:**

```
FILTERING:
  Query: "Show me all date-related chunks from claim 001"
  Filter: claim_id="claim_001" AND contains_dates=true

DEBUGGING:
  Issue: "Why was this chunk retrieved?"
  Check: semantic_topic, position_index, token_length

ANALYSIS:
  Question: "How many chunks per section?"
  Group by: section_id, count nodes

CLAIM ISOLATION:
  Requirement: "Never mix facts from different claims"
  Filter: claim_id="claim_001" (strict filtering)
```

---

## âœ… **Stage 6: Cleaning & Validation**

### **Purpose:**
Remove empty/invalid chunks and ensure all nodes are valid before output.

### **Validation Checks:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         STAGE 6: CLEANING & VALIDATION                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                          â”‚
â”‚  For each node:                                         â”‚
â”‚     â†“                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚ Check 1: Empty Text                            â”‚     â”‚
â”‚  â”‚ â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”   â”‚     â”‚
â”‚  â”‚ if not node.text or not node.text.strip():     â”‚     â”‚
â”‚  â”‚   REMOVE node                                  â”‚     â”‚
â”‚  â”‚                                                â”‚     â”‚
â”‚  â”‚ WHY: Empty chunks provide no value             â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚     â†“                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚ Check 2: Minimum Size                          â”‚     â”‚
â”‚  â”‚ â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”   â”‚     â”‚
â”‚  â”‚ if token_length < 10:                          â”‚     â”‚
â”‚  â”‚   REMOVE node                                  â”‚     â”‚
â”‚  â”‚                                                â”‚     â”‚
â”‚  â”‚ WHY: Tiny chunks are usually noise             â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚     â†“                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚ Check 3: Required Metadata                     â”‚     â”‚
â”‚  â”‚ â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”   â”‚     â”‚
â”‚  â”‚ if not node.metadata.get('claim_id'):          â”‚     â”‚
â”‚  â”‚   ADD claim_id from parent/section             â”‚     â”‚
â”‚  â”‚                                                â”‚     â”‚
â”‚  â”‚ WHY: ALL nodes MUST have claim_id              â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚     â†“                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚ Check 4: Duplicate IDs                         â”‚     â”‚
â”‚  â”‚ â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”   â”‚     â”‚
â”‚  â”‚ if node_id already seen:                       â”‚     â”‚
â”‚  â”‚   REGENERATE with unique suffix                â”‚     â”‚
â”‚  â”‚                                                â”‚     â”‚
â”‚  â”‚ WHY: Duplicate IDs break indexing              â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚     â†“                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚ Check 5: Whitespace Normalization              â”‚     â”‚
â”‚  â”‚ â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”   â”‚     â”‚
â”‚  â”‚ node.text = normalize_whitespace(node.text)    â”‚     â”‚
â”‚  â”‚                                                â”‚     â”‚
â”‚  â”‚ â€¢ Remove extra spaces                          â”‚     â”‚
â”‚  â”‚ â€¢ Normalize newlines                           â”‚     â”‚
â”‚  â”‚ â€¢ Trim leading/trailing whitespace             â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚     â†“                                                     â”‚
â”‚  Output: Clean List[BaseNode]                           â”‚
â”‚                                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“Š **Complete Example: Claim Document â†’ Nodes**

### **Input:**

```
Claim Document:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
doc_id: "claim_001"
claim_number: "001"
claimant_name: "Jon Mor"

Text (simplified):
"AUTO CLAIM FORM #001

CLAIMANT INFORMATION
Name: Jon Mor
Phone: 555-1234
Address: 123 Main St

VEHICLE DETAILS
Make: Toyota
Model: Camry
Year: 2020"
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```

---

### **Output (Hierarchical Nodes):**

```
Node Structure:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

1. Section Node (IndexNode)
   â”œâ”€ node_id: "section_0"
   â”œâ”€ text: "CLAIMANT INFORMATION"
   â””â”€ metadata: {
        section_id: "section_0",
        claim_id: "claim_001",
        claim_number: "001",
        node_type: "section"
      }

2. Parent Node (TextNode)
   â”œâ”€ node_id: "parent_section0_0"
   â”œâ”€ text: "CLAIM NUMBER: 001\nAUTO CLAIM FORM #001\n
             Name: Jon Mor\nPhone: 555-1234\nAddress: 123 Main St"
   â”œâ”€ relationships: {
        PARENT: section_0,
        CHILD: [child_parent0_0, child_parent0_1]
      }
   â””â”€ metadata: {
        parent_id: "parent_section0_0",
        section_id: "section_0",
        chunk_level: "parent",
        claim_id: "claim_001",
        claim_number: "001",
        token_length: 85,
        contains_numbers: true
      }

3. Child Node 0 (TextNode)
   â”œâ”€ node_id: "child_parent0_0"
   â”œâ”€ text: "CLAIM NUMBER: 001 AUTO CLAIM FORM #001 
             Name: Jon Mor Phone: 555-1234"
   â”œâ”€ relationships: {
        PARENT: parent_section0_0,
        SOURCE: section_0
      }
   â””â”€ metadata: {
        child_id: "child_parent0_0",
        parent_id: "parent_section0_0",
        section_id: "section_0",
        chunk_level: "child",
        claim_id: "claim_001",
        claim_number: "001",
        token_length: 45,
        is_atomic_fact: true
      }

4. Child Node 1 (TextNode)
   â”œâ”€ node_id: "child_parent0_1"
   â”œâ”€ text: "Phone: 555-1234 Address: 123 Main St"
   â”œâ”€ relationships: {
        PARENT: parent_section0_0,
        SOURCE: section_0
      }
   â””â”€ metadata: {
        child_id: "child_parent0_1",
        parent_id: "parent_section0_0",
        section_id: "section_0",
        chunk_level: "child",
        claim_id: "claim_001",
        claim_number: "001",
        token_length: 40,
        is_atomic_fact: true
      }

[... more nodes for VEHICLE DETAILS section ...]

Total Nodes: ~20-30 for typical claim document
  â€¢ 2-3 sections
  â€¢ 5-10 parent chunks
  â€¢ 15-20 child chunks
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```

---

## ğŸ¯ **Why Hierarchical Chunking?**

### **Problem with Single-Level Chunking:**

```
Single-Level (No Hierarchy):
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
All chunks are same size (e.g., 200 tokens)

Issues:
âŒ Needle queries: Chunks too large (noise)
âŒ Summary queries: Chunks too small (missing context)
âŒ No way to "zoom out" for more context
âŒ No way to "zoom in" for precise facts
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```

---

### **Solution with Hierarchical Chunking:**

```
3-Level Hierarchy:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

NEEDLE QUERIES:
  â†’ Use Child Chunks (80-150 tokens)
  â†’ High precision, atomic facts
  â†’ Example: "What is Jon Mor's phone number?"
  â†’ Retrieves: "Phone: 555-1234"

SUMMARY QUERIES:
  â†’ Use Parent Chunks (250-600 tokens)
  â†’ High recall, broad context
  â†’ Example: "Describe Jon Mor's contact info"
  â†’ Retrieves: Full claimant information paragraph

AUTO-MERGING:
  â†’ If multiple child chunks from same parent retrieved
  â†’ Automatically merge back to parent
  â†’ Provides broader context when needed

RECURSIVE RETRIEVAL:
  â†’ Start with child chunk
  â†’ Navigate up to parent if more context needed
  â†’ Navigate up to section for full context
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```

---

## ğŸ”§ **Configuration Options**

```python
chunking_pipeline = ChunkingPipeline(
    parent_chunk_size=400,        # 250-600 tokens recommended
    parent_chunk_overlap=50,      # 10-20% of chunk size
    child_chunk_size=120,         # 80-150 tokens recommended
    child_chunk_overlap=20        # 10-20% of chunk size
)

# Token Estimation:
chars_per_token = 4  # English average
```

---

### **Chunk Size Guidelines:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              CHUNK SIZE RECOMMENDATIONS                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                         â”‚
â”‚  TOO SMALL (< 50 tokens):                               â”‚
â”‚  âŒ Loses context                                       â”‚
â”‚  âŒ Incomplete facts                                    â”‚
â”‚  âŒ Poor embeddings                                     â”‚
â”‚                                                         â”‚
â”‚  CHILD CHUNKS (80-150 tokens):                          â”‚
â”‚  âœ… Atomic facts                                        â”‚
â”‚  âœ… High precision                                      â”‚
â”‚  âœ… 1-3 sentences                                       â”‚
â”‚  ğŸ“Œ Recommended: 120 tokens                             â”‚
â”‚                                                         â”‚
â”‚  PARENT CHUNKS (250-600 tokens):                        â”‚
â”‚  âœ… Semantic units                                      â”‚
â”‚  âœ… High recall                                         â”‚
â”‚  âœ… 1-2 paragraphs                                      â”‚
â”‚  ğŸ“Œ Recommended: 400 tokens                             â”‚
â”‚                                                         â”‚
â”‚  TOO LARGE (> 1000 tokens):                             â”‚
â”‚  âŒ Multiple topics mixed                               â”‚
â”‚  âŒ Poor semantic focus                                 â”‚
â”‚  âŒ Retrieval noise                                     â”‚
â”‚                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“ **Key Concepts**

### **1. Claim-Scoped Processing**

```
SINGLE-CLAIM SCOPE:
  Input: ONE claim document
  Output: Nodes for THAT claim only

WHY THIS MATTERS:
âœ… Prevents mixing facts from different claims
âœ… Each claim has independent hierarchy
âœ… Enables claim-specific filtering
âœ… No cross-claim assumptions

Example:
  Claim 001 â†’ 25 nodes (all claim_id="claim_001")
  Claim 002 â†’ 23 nodes (all claim_id="claim_002")
  Never mixed!
```

---

### **2. Deterministic Chunking**

```
SAME INPUT â†’ SAME OUTPUT:
  â€¢ Section detection: Rule-based (no ML)
  â€¢ Token estimation: Character-based (~4 chars/token)
  â€¢ Node IDs: Hash-based (deterministic)
  â€¢ No randomness anywhere

WHY THIS MATTERS:
âœ… Reproducible results
âœ… Easy debugging
âœ… Consistent across runs
âœ… Version control friendly
```

---

### **3. No Embeddings**

```
CHUNKING LAYER:
  âœ… Creates text chunks
  âœ… Builds hierarchy
  âœ… Adds metadata
  âŒ NO embeddings

INDEX LAYER:
  âœ… Takes chunks from Chunking Layer
  âœ… Creates embeddings
  âœ… Builds vector store

WHY SEPARATION:
âœ… Embeddings are expensive (only do once)
âœ… Embedding config must be consistent
âœ… Clear separation of concerns
âœ… Chunking is about structure, not vectors
```

---

## ğŸ“Š **Usage Examples**

### **Factory Function:**

```python
from RAG.Chunking_Layer import create_chunking_pipeline

# Create pipeline with default settings
pipeline = create_chunking_pipeline()

# Or with custom settings
pipeline = create_chunking_pipeline(
    parent_chunk_size=500,
    child_chunk_size=100
)

# Process a claim document
nodes = pipeline.build_nodes(claim_document)

print(f"Created {len(nodes)} nodes")
# Output: "Created 28 nodes"
#   â€¢ 2 section nodes
#   â€¢ 8 parent nodes
#   â€¢ 18 child nodes
```

---

### **Integration Example:**

```python
# Complete pipeline from PDF to Nodes

# Stage 1: PDF Ingestion
from RAG.PDF_Ingestion import create_ingestion_pipeline
ingestion = create_ingestion_pipeline()
document = ingestion.ingest("claim_form.pdf")

# Stage 2: Claim Segmentation
from RAG.Claim_Segmentation import create_claim_segmentation_pipeline
segmentation = create_claim_segmentation_pipeline()
claim_documents = segmentation.split_into_claims(document)

# Stage 3: Chunking (per claim)
from RAG.Chunking_Layer import create_chunking_pipeline
chunking = create_chunking_pipeline()

all_nodes = []
for claim_doc in claim_documents:
    nodes = chunking.build_nodes(claim_doc)
    all_nodes.extend(nodes)
    print(f"Claim {claim_doc.metadata['claim_number']}: {len(nodes)} nodes")

# Output:
# Claim 001: 28 nodes
# Claim 002: 25 nodes
# Claim 003: 30 nodes
# ...

# Stage 4: Index Layer (next)
# Creates embeddings and vector store from all_nodes
```

---

## âœ… **Summary: Chunking Layer**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           CHUNKING LAYER SUMMARY                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                         â”‚
â”‚  PURPOSE:                                               â”‚
â”‚  Transform ONE claim document into hierarchical nodes   â”‚
â”‚                                                         â”‚
â”‚  INPUT:                                                 â”‚
â”‚  â€¢ LlamaIndex Document (one claim)                      â”‚
â”‚  â€¢ From Claim Segmentation Layer                        â”‚
â”‚                                                         â”‚
â”‚  OUTPUT:                                                â”‚
â”‚  â€¢ List[BaseNode] with 3-level hierarchy:               â”‚
â”‚    - Sections (IndexNode)                               â”‚
â”‚    - Parent chunks (TextNode, 250-600 tokens)           â”‚
â”‚    - Child chunks (TextNode, 80-150 tokens)             â”‚
â”‚                                                         â”‚
â”‚  KEY FEATURES:                                          â”‚
â”‚  âœ… Hierarchical structure (3 levels)                   â”‚
â”‚  âœ… Claim-scoped (one claim at a time)                  â”‚
â”‚  âœ… Deterministic (same input â†’ same output)            â”‚
â”‚  âœ… Rich metadata (claim_id, positions, etc.)           â”‚
â”‚  âœ… Relationship linking (parent-child)                 â”‚
â”‚  âœ… Context preservation (overlaps)                     â”‚
â”‚  âŒ NO embeddings (Index Layer's job)                   â”‚
â”‚                                                         â”‚
â”‚  ENABLES:                                               â”‚
â”‚  â€¢ High-precision retrieval (child chunks)              â”‚
â”‚  â€¢ High-recall retrieval (parent chunks)                â”‚
â”‚  â€¢ AutoMergingRetriever                                 â”‚
â”‚  â€¢ RecursiveRetriever                                   â”‚
â”‚  â€¢ Claim-specific filtering                             â”‚
â”‚                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“ **Files**

| File | Purpose |
|------|---------|
| `chunking_layer.py` | Main chunking implementation |
| `__init__.py` | Module exports |
| `chunking-layer-explained.md` | This documentation |

---

**Built for RagAgentv2 - Auto Claims RAG System** ğŸš—ğŸ“š


RAG/Chunking_Layer/chunking-layer-explained.md
â”œâ”€ ğŸ“š What is the Chunking Layer?
â”œâ”€ ğŸ¯ Core Responsibility
â”œâ”€ ğŸ—ï¸ 3-Level Hierarchical Structure
â”‚   â”œâ”€ Level 1: Sections (logical divisions)
â”‚   â”œâ”€ Level 2: Parent Chunks (250-600 tokens)
â”‚   â””â”€ Level 3: Child Chunks (80-150 tokens)
â”‚
â”œâ”€ ğŸ”„ Complete Chunking Pipeline (6 Stages)
â”‚   â”œâ”€ Stage 1: Section Detection
â”‚   â”‚   â”œâ”€ Pattern matching (SECTION keywords, ALL CAPS)
â”‚   â”‚   â”œâ”€ Example with input/output
â”‚   â”‚   â””â”€ Fallback handling
â”‚   â”‚
â”‚   â”œâ”€ Stage 2: Parent Chunking
â”‚   â”‚   â”œâ”€ Paragraph-based splitting
â”‚   â”‚   â”œâ”€ 250-600 token chunks
â”‚   â”‚   â”œâ”€ Context prepending (CLAIM NUMBER)
â”‚   â”‚   â””â”€ Example with real chunks
â”‚   â”‚
â”‚   â”œâ”€ Stage 3: Child Chunking
â”‚   â”‚   â”œâ”€ Sentence-based splitting
â”‚   â”‚   â”œâ”€ 80-150 token chunks
â”‚   â”‚   â”œâ”€ Overlap mechanism
â”‚   â”‚   â””â”€ Example showing overlap benefit
â”‚   â”‚
â”‚   â”œâ”€ Stage 4: Relationship Linking
â”‚   â”‚   â”œâ”€ Parent-child connections
â”‚   â”‚   â”œâ”€ Hierarchical navigation
â”‚   â”‚   â””â”€ Relationship graph visualization
â”‚   â”‚
â”‚   â”œâ”€ Stage 5: Metadata Enrichment
â”‚   â”‚   â”œâ”€ Structural metadata
â”‚   â”‚   â”œâ”€ Claim metadata (claim_id, etc.)
â”‚   â”‚   â”œâ”€ Semantic metadata
â”‚   â”‚   â””â”€ Why metadata matters
â”‚   â”‚
â”‚   â””â”€ Stage 6: Cleaning & Validation
â”‚       â”œâ”€ Empty text removal
â”‚       â”œâ”€ Minimum size check
â”‚       â”œâ”€ Required metadata validation
â”‚       â””â”€ Whitespace normalization
â”‚
â”œâ”€ ğŸ“Š Complete Example: Claim Document â†’ Nodes
â”‚   â””â”€ Full transformation with all node details
â”‚
â”œâ”€ ğŸ¯ Why Hierarchical Chunking?
â”‚   â”œâ”€ Problem with single-level
â”‚   â”œâ”€ Solution with 3-level hierarchy
â”‚   â”œâ”€ Needle queries (child chunks)
â”‚   â”œâ”€ Summary queries (parent chunks)
â”‚   â””â”€ Auto-merging & recursive retrieval
â”‚
â”œâ”€ ğŸ”§ Configuration Options
â”‚   â”œâ”€ Chunk size parameters
â”‚   â””â”€ Size guidelines (with recommendations)
â”‚
â”œâ”€ ğŸ“ Key Concepts
â”‚   â”œâ”€ Claim-scoped processing
â”‚   â”œâ”€ Deterministic chunking
â”‚   â””â”€ No embeddings (separation of concerns)
â”‚
â”œâ”€ ğŸ“Š Usage Examples
â”‚   â”œâ”€ Factory function
â”‚   â””â”€ Integration example (full pipeline)
â”‚
â”œâ”€ âœ… Summary
â””â”€ ğŸ“ Files Reference


ğŸ¯ Key Takeaways:

1. 3-LEVEL HIERARCHY:
   Section (container) â†’ Parent (context) â†’ Child (atomic facts)

2. CLAIM-SCOPED:
   Each claim processed independently, never mixed

3. DETERMINISTIC:
   Same input always produces same output

4. NO EMBEDDINGS:
   Chunking = structure, Index Layer = vectors

5. RICH METADATA:
   Every node tagged with claim_id and position info

6. ENABLES PRECISION & RECALL:
   Child chunks = precision, Parent chunks = recall